import theano
import theano.tensor as T
from theano.gradient import grad_undefined
import numpy as np

class KSparseGrad(theano.Op):
    """ ksparse gradient """
    def __eq__(self,other):
        return type(self) == type(other)

    def __hash__(self):
        return hash(type(self))

    def __str__(self):
        return "KSparseWRT"
        
    def make_node(self, I, k, axis, dCdH):
        """
            :param I: input vector
            :param k: number of non-zero elements
            :params axis: axis to be quickselected
        """
        I_ = T.as_tensor_variable(I)
        k_ = T.as_tensor_variable(k)
        axis_ = T.as_tensor_variable(axis)
        dCdH_ = T.as_tensor_variable(dCdH)

        node = theano.Apply(self, inputs=[I_, k_, axis_, dCdH_], outputs = [ T.TensorType(I_.dtype, tuple([I_.broadcastable[i] for i in xrange(I_.ndim)]))() ] )

        return node
     
    def perform(self, node, inputs, output_storage):
        I, k, axis, dCdH = inputs
        #print "KSparse python code"
        nfmaps = I.shape[axis]
        npixels = np.asarray(I.shape[axis+1:]).prod(dtype=int)
        nsamples = np.asarray(I.shape[:axis]).prod(dtype=int)
        lsample = npixels * nfmaps

        indices = np.zeros(nfmaps,dtype=np.int_)
        H = np.zeros(I.size)

        for s in range(nsamples):
            for p in range(npixels):
                for fm in range(nfmaps):
                    indices[fm] = s * lsample + p + fm * npixels
                sortinds = np.argsort(-(I.reshape(I.size)[indices]))
                indices = indices[sortinds]
                H[indices[:k]] = dCdH.reshape(dCdH.size)[indices[:k]]

        output_storage[0][0] = H.reshape(I.shape)

    def c_code(self, node, nodename, inputs, outputs, sub):
        I, k, axis, dCdH = inputs
        H = outputs[0]

        codeSource =  """
            ///////////// < code generated by kSparse >
            {
                #define SWAP(ai,bi) ind_temp=(arr_ind[ai]);(arr_ind[ai])=(arr_ind[bi]);(arr_ind[bi])=ind_temp;
                int i, ir, j, l, mid, ind_temp, s, p, fm;

                const dtype_%(axis)s axis = *(dtype_%(axis)s*) PyArray_GETPTR1(%(axis)s,0);
                const dtype_%(k)s k = *(dtype_%(k)s*) PyArray_GETPTR1(%(k)s,0);
                dtype_%(I)s * arr = (dtype_%(I)s*)PyArray_DATA(%(I)s);
                dtype_%(dCdH)s * dCdH = (dtype_%(dCdH)s*)PyArray_DATA(%(dCdH)s);

                //dtype_%(k)s * k = (dtype_%(k)s*)PyArray_DATA(%(k)s);
                //dtype_%(axis)s * axis = (dtype_%(axis)s*)PyArray_DATA(%(axis)s);

                const int ndims = PyArray_NDIM(%(I)s);
                //const npy_intp shape = PyArray_DIMS(%(I)s);

        

                const int nfmaps = PyArray_DIM(%(I)s, axis);

                unsigned int npixels = 1;
                
                

                //const dtype_%(I)s arr = *(dtype_%(I)s*) PyArray_GETPTR1(%(I)s,0);

                

	            for (i = axis + 1; i < ndims; i++)
		            npixels *= PyArray_DIMS(%(I)s)[i];

                const unsigned int lsample = npixels * nfmaps;

                unsigned int nsamples = 1;
            
                for (i = 0; i < axis; i++)
        	        nsamples *= PyArray_DIMS(%(I)s)[i];

       
                %(H)s = (PyArrayObject*) PyArray_ZEROS(ndims, PyArray_DIMS(%(I)s), PyArray_ObjectType((PyObject*)%(I)s, 0), 0);
                dtype_%(H)s * H = (dtype_%(H)s*)PyArray_DATA(%(H)s);


                unsigned int arr_ind[PyArray_DIMS(%(I)s)[axis]];
            
	            for (s = 0; s < nsamples; s++) {
		            for (p = 0; p < npixels; p++) {
                        
                        for (fm = 0; fm<nfmaps; fm++) //iterate over feature maps
				            // s * lsample: a sample has length lsample, jump to s-th sample
				            // + p : jump to the current pixel on the first feature map
				            // + fm * npixels : a pixel recurrs every npixels entries of arr, i.e., adding this jumps to pixel p on feautre map fm
				            arr_ind[fm] = s * lsample + p + fm * npixels;
                        int a;

			            l = 0;
			            ir = nfmaps - 1;
			            for (;;) {
				            if (ir <= l + 1) {
					            if (ir == l + 1 && arr[arr_ind[ir]] > arr[arr_ind[l]]) {
						            SWAP(l, ir);
					            }
					            break;
				            }
				            else {
					            mid = (l + ir) >> 1;
					            SWAP(mid, l + 1);
					            if (arr[arr_ind[l]] < arr[arr_ind[ir]]) {
						            SWAP(l, ir);
					            }
					            if (arr[arr_ind[l + 1]] < arr[arr_ind[ir]]) {
						            SWAP(l + 1, ir);
					            }
					            if (arr[arr_ind[l]] < arr[arr_ind[l + 1]]) {
						            SWAP(l, l + 1);
					            }
					            i = l + 1;
					            j = ir;
					            a = arr_ind[l + 1];
					            for (;;) {
						            do i++; while (arr[arr_ind[i]] > arr[a]);
						            do j--; while (arr[arr_ind[j]] < arr[a]);
						            if (j < i) break;
						            SWAP(i, j);
					            }
					            arr_ind[l + 1] = arr_ind[j];
					            arr_ind[j] = a;
					            if (j >= k) ir = j - 1;
					            if (j <= k) l = i;
				            }
			            }
                        // ksparse, copy smallest k entries
                        for (i = 0; i < k; i++) {
                            H[arr_ind[i]] = dCdH[arr_ind[i]];
                        }
		            }
	            }
            }


            
            ///////////// < end code generated by kSparse >
        """ % locals()

        return codeSource


    def infer_shape(self, node, input_shapes):
        I, k, axis, dCdH = node.inputs
        I_shape, k_shape, axis_shape, dCdH_shape = input_shapes

        return [ I_shape ]

class KSparse(theano.Op):
    """ ksparse funktion """
    def __eq__(self,other):
        return type(self) == type(other)

    def __hash__(self):
        return hash(type(self))

    def __str__(self):
        return "kSparse"
        
    def make_node(self, I, k, axis):
        """
            :param I: input vector
            :param k: number of non-zero elements
            :params axis: axis to be quickselected
        """

        I_ = T.as_tensor_variable(I)
        k_ = T.as_tensor_variable(k)
        axis_ = T.as_tensor_variable(axis)
        node = theano.Apply(self, inputs=[I_, k_, axis_], outputs = [ T.TensorType(I_.dtype,  tuple([I_.broadcastable[i] for i in xrange(I_.ndim)]))() ] )

        return node
                                                   
    def grad(self, inputs, output_gradients):
        I,k,axis = inputs
        dCdH ,= output_gradients

        dCdI = KSparseGrad()(I,k,axis,dCdH)
        dCdI = T.patternbroadcast(dCdI, I.broadcastable)
        
        dCdk = grad_undefined(self,1,inputs[1],
                "The gradient of ksparse with respect to the number"+\
                " of non-zero elements is undefined")

        dCdaxis = grad_undefined(self,1,inputs[2],
                "The gradient of ksparse with respect to the sorting"+\
                " axis is undefined")

        

        if 'name' in dir(dCdH) and dCdH.name is not None:
            dCdH_name = dCdH.name
        else:
            dCdH_name = 'anon_dCdH'

        if 'name' in dir(I) and I.name is not None:
            I_name = I.name
        else:
            I_name = 'anon_I'

        if 'name' in dir(k) and k.name is not None:
            k_name = k.name
        else:
            k_name = 'anon_k'

        if 'name' in dir(axis) and axis.name is not None:
            k_name = axis.name
        else:
            axis_name = 'anon_axis'

        #add axis

        dCdI.name = 'KSparse_dCdI(dCdH='+dCdH_name+',I='+I_name+')'
        dCdk.name = 'KSparse_dCdk(dCdH='+dCdH_name+',I='+I_name+',k='+k_name+')'
        dCdaxis.name = 'KSparse_dCdk(dCdH='+dCdH_name+',I='+I_name+',k='+k_name+',axis='+axis_name+')'

        return [ dCdI, dCdk, dCdaxis ]
        
    def perform(self, node, inputs, output_storage):
        I, k, axis = inputs
        #print "KSparse python code"
        
        nfmaps = I.shape[axis]
        npixels = np.asarray(I.shape[axis+1:]).prod(dtype=int)
        nsamples = np.asarray(I.shape[:axis]).prod(dtype=int)
        lsample = npixels * nfmaps

        indices = np.zeros(nfmaps,dtype=np.int_)

        H = np.zeros(I.size)

        for s in range(nsamples):
            for p in range(npixels):
                
                for fm in range(nfmaps):
                    indices[fm] = s * lsample + p + fm * npixels

                sortinds = np.argsort(-(I.reshape(I.size)[indices]))
                indices = indices[sortinds]

                H[indices[:k]] = I.reshape(I.size)[indices[:k]]
        
        output_storage[0][0] = H.reshape(I.shape)


    def c_code(self, node, nodename, inputs, outputs, sub):
        I, k, axis = inputs
        H = outputs[0]

        codeSource =  """
            ///////////// < code generated by kSparse >
            {
                #define SWAP(ai,bi) ind_temp=(arr_ind[ai]);(arr_ind[ai])=(arr_ind[bi]);(arr_ind[bi])=ind_temp;
                int i, ir, j, l, mid, ind_temp, s, p, fm;

                const dtype_%(axis)s axis = *(dtype_%(axis)s*) PyArray_GETPTR1(%(axis)s,0);
                const dtype_%(k)s k = *(dtype_%(k)s*) PyArray_GETPTR1(%(k)s,0);
                dtype_%(I)s * arr = (dtype_%(I)s*)PyArray_DATA(%(I)s);
                //dtype_%(k)s * k = (dtype_%(k)s*)PyArray_DATA(%(k)s);
                //dtype_%(axis)s * axis = (dtype_%(axis)s*)PyArray_DATA(%(axis)s);

                const int ndims = PyArray_NDIM(%(I)s);
                //const npy_intp shape = PyArray_DIMS(%(I)s);

        

                const int nfmaps = PyArray_DIM(%(I)s, axis);

                unsigned int npixels = 1;
                
                

                //const dtype_%(I)s arr = *(dtype_%(I)s*) PyArray_GETPTR1(%(I)s,0);

                

	            for (i = axis + 1; i < ndims; i++)
		            npixels *= PyArray_DIMS(%(I)s)[i];

                const unsigned int lsample = npixels * nfmaps;

                unsigned int nsamples = 1;
            
                for (i = 0; i < axis; i++)
        	        nsamples *= PyArray_DIMS(%(I)s)[i];

       
                %(H)s = (PyArrayObject*) PyArray_ZEROS(ndims, PyArray_DIMS(%(I)s), PyArray_ObjectType((PyObject*)%(I)s, 0), 0);
                dtype_%(H)s * H = (dtype_%(H)s*)PyArray_DATA(%(H)s);


                unsigned int arr_ind[PyArray_DIMS(%(I)s)[axis]];
            
	            for (s = 0; s < nsamples; s++) {
		            for (p = 0; p < npixels; p++) {
                        
                        for (fm = 0; fm<nfmaps; fm++) //iterate over feature maps
				            // s * lsample: a sample has length lsample, jump to s-th sample
				            // + p : jump to the current pixel on the first feature map
				            // + fm * npixels : a pixel recurrs every npixels entries of arr, i.e., adding this jumps to pixel p on feautre map fm
				            arr_ind[fm] = s * lsample + p + fm * npixels;
                        int a;

			            l = 0;
			            ir = nfmaps - 1;
			            for (;;) {
				            if (ir <= l + 1) {
					            if (ir == l + 1 && arr[arr_ind[ir]] > arr[arr_ind[l]]) {
						            SWAP(l, ir);
					            }
					            break;//return arr[arr_ind[%(k)s]];
				            }
				            else {
					            mid = (l + ir) >> 1;
					            SWAP(mid, l + 1);
					            if (arr[arr_ind[l]] < arr[arr_ind[ir]]) {
						            SWAP(l, ir);
					            }
					            if (arr[arr_ind[l + 1]] < arr[arr_ind[ir]]) {
						            SWAP(l + 1, ir);
					            }
					            if (arr[arr_ind[l]] < arr[arr_ind[l + 1]]) {
						            SWAP(l, l + 1);
					            }
					            i = l + 1;
					            j = ir;
					            a = arr_ind[l + 1];
					            for (;;) {
						            do i++; while (arr[arr_ind[i]] > arr[a]);
						            do j--; while (arr[arr_ind[j]] < arr[a]);
						            if (j < i) break;
						            SWAP(i, j);
					            }
					            arr_ind[l + 1] = arr_ind[j];
					            arr_ind[j] = a;
					            if (j >= k) ir = j - 1;
					            if (j <= k) l = i;
				            }
			            }
                        // ksparse, copy smallest k entries
                        for (i = 0; i < k; i++) {
                            H[arr_ind[i]] = arr[arr_ind[i]];
                        }
		            }
	            }
            }


            
            ///////////// < end code generated by kSparse >
        """ % locals()

        return codeSource

    def infer_shape(self, node, input_shapes):
        I,k,axis = node.inputs
        I_shape, k_shape, axis_shape = input_shapes

        return [ I_shape ]
        
global kSparse
kSparse = KSparse()  

if __name__ == "__main__":
    x = theano.tensor.fmatrix()
    f = theano.function([x],[kSparse(x,10)])
    print f(np.random.random((10,100)).astype('float32'))

    f_grad = theano.function([x],[T.grad(1000.0*np.mean(kSparse(x,10)*x),x)])
    print f_grad(np.random.random((10,100)).astype('float32'))
        
        
        
